# -*- coding: utf-8 -*-
"""CNN_acclerator.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BvoFmtEQj4GZVc30W-YiZu0e93tXOMGt
"""

import numpy as np
import tensorflow as tf

# --- Helper Function to Write .mem Files ---
def write_mem_file(filename, data_array):
    """
    Flattens a 2D numpy array and writes it as a BINARY .mem file
    for robust parsing by Vivado's $readmemb.
    """
    # Flatten the 2D array to a 1D vector
    flat_data = data_array.flatten()
    # Use standard ascii encoding and Unix-style line endings
    with open(filename, 'w', encoding='ascii', newline='\n') as f:
        for val in flat_data:
            # Format as an 8-digit binary string
            f.write(f"{int(val):08b}\n")
    print(f"Successfully wrote {len(flat_data)} values to {filename}")

# --- 1. Load a Reference Model and Data ---
print("--- Step 1: Loading MNIST data ---")
# Load the MNIST dataset
(x_train, y_train), (_, _) = tf.keras.datasets.mnist.load_data()

# Take a single image to act as our source feature map
# We'll use the first image, which is a '5'
input_image = x_train[0]

# Normalize the image data to the [0, 1] range for processing
input_image_float = input_image.astype('float32') / 255.0

print(f"Loaded a {input_image.shape} image.")

# --- 2. Extract a 3x3 Feature Map and a 3x3 Kernel ---
print("\n--- Step 2: Extracting Feature Map and Kernel ---")

# For this example, we'll take a 3x3 slice from the center of the image
# This will be our feature map for the accelerator
fmap_slice_float = input_image_float[13:16, 13:16]

# Create a sample 3x3 kernel with some interesting float values
# In a real model, these would be the trained weights
kernel_float = np.array([
    [ 0.85, -0.12,  0.33],
    [-0.45,  0.67, -0.99],
    [ 0.10,  0.25,  0.50]
], dtype=np.float32)

print("Extracted 3x3 feature map slice and defined a 3x3 kernel.")


# --- 3. Quantize Data (Float32 -> uint8) ---
print("\n--- Step 3: Quantizing data to 8-bit integers ---")

# Quantize the feature map (already in 0-1 range)
fmap_quantized = np.round(fmap_slice_float * 255).astype(np.uint8)

# Quantize the kernel. First, scale weights from [-1, 1] to [0, 1], then to [0, 255]
kernel_scaled = (kernel_float + 1.0) / 2.0 # Scale to 0-1 range
kernel_quantized = np.round(kernel_scaled * 255).astype(np.uint8)

print("Quantized Feature Map (uint8):\n", fmap_quantized)
print("\nQuantized Kernel (uint8):\n", kernel_quantized)


# --- 4. Write .mem Files for Vivado Simulation ---
print("\n--- Step 4: Writing .mem files ---")
write_mem_file('fmap.mem', fmap_quantized)
write_mem_file('kernel.mem', kernel_quantized)


# --- 5. Calculate the Golden Reference ---
print("\n--- Step 5: Calculating Golden Reference ---")
# Cast arrays to a wider integer type (like uint32) BEFORE multiplication
# to prevent intermediate overflow, perfectly matching the hardware's behavior.
fmap_wide = fmap_quantized.astype(np.uint32)
kernel_wide = kernel_quantized.astype(np.uint32)
golden_result = np.sum(fmap_wide * kernel_wide)

print(f"\nFeature Map Values (flat): {fmap_quantized.flatten()}")
print(f"Kernel Values (flat):      {kernel_quantized.flatten()}")
print("\n-------------------------------------------------")
print(f"Golden Reference Result: {golden_result} (0x{golden_result:05x})")
print("-------------------------------------------------")
print("\nThis is the value your Verilog testbench should expect!")